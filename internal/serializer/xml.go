package serializer

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/rs/zerolog/log"
)

// XMLSerializer provides methods to write multiple files' contents into an
// XML-formatted document optimized for LLM parsing.
type XMLSerializer struct{}

// NewXMLSerializer returns a new instance of XMLSerializer.
func NewXMLSerializer() *XMLSerializer {
	return &XMLSerializer{}
}

// Serialize takes a list of file paths relative to baseDir, reads and normalizes
// each file's content, and writes them to writer in a simplified XML format for LLMs.
// If reading any file fails, it logs a warning and skips that file.
// If showTree is true, it includes a plain text directory tree visualization.
// If redactionInfo is not nil, it redacts secrets from the output.
// largeFileSizeThreshold defines the size in bytes above which a file is considered "large"
// and a warning will be logged.
func (s *XMLSerializer) Serialize(writer io.Writer, baseDir string, filePaths []string, showTree bool, redactionInfo *RedactionInfo, largeFileSizeThreshold int64) error {
	// Write header as plain text before XML content
	timestamp := time.Now().UTC().Format(time.RFC3339Nano)
	header := fmt.Sprintf("This document contains a structured representation of the entire codebase, merging all files into a single XML file.\n\nGenerated by Grimoire on: %s\n\n", timestamp)

	if _, err := writer.Write([]byte(header)); err != nil {
		return fmt.Errorf("failed to write header: %w", err)
	}

	// Write the summary section
	summary := "<summary>\n"
	summary += "This file contains a packed representation of the entire codebase's contents. "
	summary += "It is designed to be easily consumable by AI systems for analysis, code review, or other automated processes.\n\n"
	summary += "- This file should be treated as read-only. Any changes should be made to the original codebase files.\n"
	summary += "- When processing this file, use the file path attributes to distinguish between different files.\n"
	summary += "- This file may contain sensitive information and should be handled with appropriate care.\n"

	if redactionInfo != nil && redactionInfo.Enabled {
		summary += "- Detected secrets have been redacted with the format [REDACTED SECRET: description].\n"
	}

	summary += "- Some files may have been excluded based on .gitignore rules and Grimoire's configuration.\n"

	if showTree {
		summary += "- The file begins with this summary, followed by the directory structure, and then includes all codebase files.\n"
	} else {
		summary += "- The file begins with this summary, followed by all codebase files.\n"
	}

	summary += "</summary>\n\n"

	if _, err := writer.Write([]byte(summary)); err != nil {
		return fmt.Errorf("failed to write summary: %w", err)
	}

	// Add directory tree if requested
	if showTree && len(filePaths) > 0 {
		if _, err := writer.Write([]byte("<directory_structure>\n")); err != nil {
			return fmt.Errorf("failed to write directory structure opening tag: %w", err)
		}

		treeGen := NewDefaultTreeGenerator()
		rootNode := treeGen.GenerateTree(filePaths)

		// Generate plain text tree with indentation
		treeContent := s.renderTreeAsPlainText(rootNode, 0)

		if _, err := writer.Write([]byte(treeContent)); err != nil {
			return fmt.Errorf("failed to write directory tree content: %w", err)
		}

		if _, err := writer.Write([]byte("</directory_structure>\n\n")); err != nil {
			return fmt.Errorf("failed to write directory structure closing tag: %w", err)
		}
	}

	// Write files opening tag
	if _, err := writer.Write([]byte("<files>\n")); err != nil {
		return fmt.Errorf("failed to write files opening tag: %w", err)
	}

	// Process each file
	for _, relPath := range filePaths {
		// Read and normalize file content
		content, isLargeFile, err := s.readAndNormalizeContent(baseDir, relPath, redactionInfo, largeFileSizeThreshold)
		if err != nil {
			log.Warn().Err(err).Msgf("Skipping file %s due to read error", relPath)
			continue
		}

		if isLargeFile {
			log.Warn().Msgf("File %s exceeds the large file threshold (%d bytes). Including in output but this may impact performance.", relPath, largeFileSizeThreshold)
		}

		// Check if the file is minified (only if applicable file type)
		if IsMinifiedFile(content, relPath, DefaultMinifiedFileThresholds) {
			log.Warn().Msgf("File %s appears to be minified. Consider excluding it to reduce token counts.", relPath)
		}

		// Write file tag with path attribute
		fileOpenTag := fmt.Sprintf("<file path=\"%s\">\n", relPath)
		if _, err := writer.Write([]byte(fileOpenTag)); err != nil {
			return fmt.Errorf("failed to write file opening tag for %s: %w", relPath, err)
		}

		// Write file content directly inside the file tag
		if _, err := writer.Write([]byte(content)); err != nil {
			return fmt.Errorf("failed to write content for %s: %w", relPath, err)
		}

		// Write file closing tag
		if _, err := writer.Write([]byte("\n</file>\n")); err != nil {
			return fmt.Errorf("failed to write file closing tag for %s: %w", relPath, err)
		}
	}

	// Write files closing tag
	if _, err := writer.Write([]byte("</files>\n")); err != nil {
		return fmt.Errorf("failed to write files closing tag: %w", err)
	}

	return nil
}

// renderTreeAsPlainText recursively builds a plain text representation of the tree with
// indentation for easier LLM parsing.
func (s *XMLSerializer) renderTreeAsPlainText(node *TreeNode, depth int) string {
	if node == nil {
		return ""
	}

	var builder strings.Builder

	// Skip the root node in output
	if node.Name != "" {
		// Create indentation based on depth
		indent := strings.Repeat("  ", depth)

		// Add name and directory indicator if applicable
		builder.WriteString(indent)
		builder.WriteString(node.Name)

		if node.IsDir {
			builder.WriteString("/")
		}

		builder.WriteString("\n")
	}

	// Process children with incremented depth
	for _, child := range node.Children {
		childDepth := depth
		if node.Name != "" {
			// Only increment depth for non-root nodes
			childDepth++
		}
		builder.WriteString(s.renderTreeAsPlainText(child, childDepth))
	}

	return builder.String()
}

// readAndNormalizeContent reads a file from baseDir/relPath and normalizes its
// content by trimming surrounding whitespace and trailing spaces on each line.
// If redactionInfo is not nil, it redacts secrets from the output.
// It also checks if the file exceeds the large file size threshold and returns a flag if it does.
func (s *XMLSerializer) readAndNormalizeContent(baseDir, relPath string, redactionInfo *RedactionInfo, largeFileSizeThreshold int64) (string, bool, error) {
	fullPath := filepath.Join(baseDir, relPath)

	// Check file size before reading
	fileInfo, err := os.Stat(fullPath)
	if err != nil {
		return "", false, fmt.Errorf("failed to stat file %s: %w", fullPath, err)
	}

	// Check if file exceeds large file threshold
	isLargeFile := fileInfo.Size() > largeFileSizeThreshold

	contentBytes, err := os.ReadFile(fullPath)
	if err != nil {
		return "", false, fmt.Errorf("failed to read file %s: %w", fullPath, err)
	}

	// Convert bytes to string and normalize
	content := string(contentBytes)
	normalizedContent := s.normalizeContent(content)

	// If redaction is enabled, redact any secrets
	if redactionInfo != nil && redactionInfo.Enabled {
		fileFindings := GetFindingsForFile(redactionInfo, relPath, baseDir)
		if len(fileFindings) > 0 {
			normalizedContent = RedactSecrets(normalizedContent, fileFindings)
		}
	}

	return normalizedContent, isLargeFile, nil
}

// normalizeContent trims surrounding whitespace and trailing spaces from each line
// of the input text, then returns the transformed string.
func (s *XMLSerializer) normalizeContent(content string) string {
	content = strings.TrimSpace(content)
	lines := strings.Split(content, "\n")

	for i, line := range lines {
		lines[i] = strings.TrimRight(line, " \t")
	}

	return strings.Join(lines, "\n")
}
